# Как работает слайс в Go и зачем нужен make
Этот проект показывает простую реализацию динамического массива (слайса) на C, который работает похожим образом, как слайсы в языке Go.

---

## Что такое слайс в Go?

Слайс — это структура из трёх частей:

- **указатель на массив элементов**  
- **текущая длина (`len`)**  
- **вместимость (`cap`)**

Когда создаёшь слайс, Go выделяет базовый массив определённой вместимости, а длина показывает, сколько элементов уже занято.

---

## Зачем использовать `make()` при создании слайса?

Функция `make([]T, len, cap)` в Go выделяет память сразу под массив с вместимостью `cap`.

- Это позволяет добавлять элементы без перераспределения памяти, пока длина меньше вместимости.  
- Если при добавлении длина достигает вместимости, Go автоматически выделит новый массив с увеличенной вместимостью (обычно в 2 раза больше), скопирует данные, обновит указатель.

---

## Как это связано кодом на C?

В коде при добавлении элемента:

```c
if (slice.cap <= slice.len) {
    slice.cap = (slice.cap == 0) ? 2 : slice.cap * 2;

    short *new = malloc(slice.cap * sizeof(short));
    for (size_t i = 0; i < slice.len; i++) {
        new[i] = slice.arr[i];
    }

    free(slice.arr);
    slice.arr = new;
}
slice.arr[slice.len++] = element;
```

Ты делаешь ровно то же самое, что Go делает за тебя автоматически:

- Проверяешь, хватает ли места (`len >= cap`)
- Удваиваешь вместимость
- Выделяешь новый массив
- Копируешь данные из старого массива
- Освобождаешь старый массив
- Добавляешь новый элемент

---

## Почему это важно для производительности?

Если не выделять память заранее (например, через `make` в Go или заранее увеличивая `cap` в C), то придётся часто выделять память и копировать данные. Это очень дорого по времени и ресурсам.

Использование `make` в Go:
- Снизить количество выделений памяти
- Уменьшить количество копирований
- Повысить скорость работы программы

---

## Итог

- Go слайсы скрывают всю сложность управления памятью и динамического расширения  
- `make` выделяет память с запасом, чтобы увеличить производительность  
- C-код показывает, как работает эта логика "под капотом" в Go  
- В C нужно делать всё вручную и быть аккуратным с памятью, чтобы избежать ошибок
